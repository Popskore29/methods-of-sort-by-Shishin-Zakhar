Блочная (корзинная) сортировка
-
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

Временная сложность: O(n + k) в среднем, O(n²) в худшем случае

Почему возникает:
Создание корзин и распределение элементов: O(n)
Сортировка каждой корзины: зависит от алгоритма сортировки внутри корзин
В худшем случае, когда все элементы попадают в одну корзину, получаем O(n²)
При равномерном распределении: O(n + n log(n/k)) = O(n + k)

Принцип работы
Определяется количество корзин 
buckets = [[] for _ in range(num_buckets)]

Каждый элемент помещается в корзину согласно функции распределения
index = int((num - min_val) / (max_val - min_val) * (num_buckets - 1))
buckets[index].append(num)

Содержимое каждой корзины сортируется индивидуально
for bucket in buckets:
    bucket.sort()

Корзины соединяются в порядке увеличения диапазона
for bucket in buckets:
    sorted_arr.extend(bucket)

Особенности: Эффективна для равномерно распределённых числовых данных и может достигать линейной асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает при неравномерном распределении данных.

Блинная сортировка
-
Определение: Блинная сортировка (pancake sort) — это алгоритм сортировки, в котором разрешена только одна операция — переворот префикса массива (как будто переворачиваем стопку блинов). Алгоритм последовательно перемещает максимальные элементы в конец массива с помощью серии переворотов.

Временная сложность: O(n²)

Почему возникает:
Внешний цикл выполняется n раз
Поиск максимума в несортированной части: O(n)
Каждая операция переворота: O(n)
Итого: O(n) × O(n) = O(n²)

Принцип работы
Находим позицию максимального элемента в несортированной части
max_idx = arr.index(max(arr[:size]))

Переворачиваем массив до позиции максимума, чтобы он оказался в начале
if max_idx != 0:
    arr[:max_idx + 1] = reversed(arr[:max_idx + 1])

Переворачиваем несортированную часть, ставя максимум на правильную позицию
arr[:size] = reversed(arr[:size])

Уменьшаем размер несортированной части и повторяем
for size in range(n, 1, -1):
Особенности: Алгоритм интересен с теоретической точки зрения, но на практике неэффективен из-за квадратичной сложности. Используется в задачах, где разрешены только операции переворота.

Сортировка бусинами (гравитационная)
-
Определение: Сортировка бусинами (bead sort) — это алгоритм, основанный на физической аналогии с бусинами, падающими под действием гравитации. Каждое число представляется как набор бусин на вертикальных стержнях, после "падения" бусины выстраиваются в отсортированном порядке.

Временная сложность: O(n × m) где m — максимальное число

Почему возникает:
Количество операций пропорционально общему числу бусин
Максимальное количество бусин: n × m
Каждая операция с бусиной: O(1)
Итого: O(n × m)

Принцип работы:
Представляем массив как набор вертикальных стержней с бусинами
"Включаем гравитацию" — бусины падают вниз
После падения подсчитываем количество бусин на каждом стержне
Получаем отсортированный массив

```
def bead_sort(arr):
    if not arr: return []
    max_val = max(arr)
    # Создаем "абак" с бусинами
    abacus = [[1 if j < num else 0 for j in range(max_val)] for num in arr]
    # "Падаем" бусинами
    for i in range(max_val):
        for j in range(len(arr)):
            if abacus[j][i] == 1:
                # Бусина падает вниз
                k = j
                while k > 0 and abacus[k-1][i] == 0:
                    abacus[k][i], abacus[k-1][i] = abacus[k-1][i], abacus[k][i]
                    k -= 1
    # Восстанавливаем отсортированный массив
    return [sum(row) for row in abacus]
```
Особенности: Работает только для неотрицательных целых чисел. Эффективна когда m (максимальное значение) мало по сравнению с n.

Поиск скачками
-
Определение: Поиск скачками (jump search) — это алгоритм поиска в отсортированном массиве, который сочетает линейный поиск с прыжками фиксированного размера. Алгоритм прыгает вперед, пока не найдет блок, содержащий искомый элемент, затем выполняет линейный поиск в этом блоке.

Временная сложность: O(√n)

Почему возникает:
Оптимальный размер прыжка: √n
Количество прыжков: n/√n = √n
Линейный поиск в блоке размером √n: O(√n)
Итого: O(√n) + O(√n) = O(√n)

Принцип работы:
Определяем размер прыжка (обычно √n)
Прыгаем вперед, пока не найдем элемент больше или равный искомому
Возвращаемся к предыдущей позиции
Выполняем линейный поиск в найденном блоке

```
import math

def jump_search(arr, target):
    n = len(arr)
    step = int(math.sqrt(n))
    prev = 0
    
    while arr[min(step, n) - 1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    for i in range(prev, min(step, n)):
        if arr[i] == target:
            return i
    return -1
```
Особенности: Эффективен когда массив слишком велик для полного линейного поиска, но бинарный поиск слишком сложен. Требует отсортированного массива.

Экспоненциальный поиск
-
Определение: Экспоненциальный поиск (exponential search) — это алгоритм поиска в отсортированном массиве, который сначала находит диапазон, содержащий искомый элемент, экспоненциально увеличивая границы, затем выполняет бинарный поиск в этом диапазоне.

Временная сложность: O(log n)

Почему возникает:
Экспоненциальное нахождение границы: O(log n)
Бинарный поиск в диапазоне: O(log n)
Итого: O(log n) + O(log n) = O(log n)

Принцип работы:
Начинаем с первого элемента
Удваиваем верхнюю границу пока не найдем диапазон, содержащий искомый элемент
Выполняем бинарный поиск в найденном диапазоне
```
def exponential_search(arr, target):
    if arr[0] == target:
        return 0
    
    n = len(arr)
    i = 1
    while i < n and arr[i] <= target:
        i *= 2
    
    # Бинарный поиск в диапазоне [i/2, min(i, n-1)]
    left, right = i // 2, min(i, n - 1)
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```
Особенности: Особенно эффективен для неограниченных массивов. Всегда работает за O(log n) независимо от положения элемента.

Тернарный поиск
-
Определение: Тернарный поиск (ternary search) — это алгоритм поиска в отсортированном массиве, который делит поисковое пространство на три равные части и рекурсивно сужает область поиска.

Временная сложность: O(log₃n)

Почему возникает:
На каждой итерации отбрасывается 2/3 поискового пространства
Количество итераций: log₃n
На каждой итерации: O(1) операций
Итого: O(log₃n)

Принцип работы:
Делим текущий диапазон на три равные части
Сравниваем искомый элемент с граничными значениями
Определяем, в какой трети находится элемент
Рекурсивно повторяем для выбранной трети

```
def ternary_search(arr, target):
    def search(left, right):
        if left > right:
            return -1
        
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        if arr[mid1] == target:
            return mid1
        if arr[mid2] == target:
            return mid2
            
        if target < arr[mid1]:
            return search(left, mid1 - 1)
        elif target > arr[mid2]:
            return search(mid2 + 1, right)
        else:
            return search(mid1 + 1, mid2 - 1)
    
    return search(0, len(arr) - 1)
```
Особенности: Менее эффективен чем бинарный поиск (больше сравнений на каждой итерации). Используется в основном для поиска экстремумов унимодальных функций.
